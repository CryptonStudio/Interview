# Вопросы для интервью по теме: Typescript

### Что такое TypeScript, и в чем отличие от JavaScript?
TypeScript - это язык программирования, который представляет собой надстройку над JavaScript, добавляющую статическую типизацию и некоторые другие возможности, которых нет в обычном JavaScript. Основные отличия между TypeScript и JavaScript:

1. Статическая типизация: TypeScript позволяет явно указывать типы данных для переменных, параметров функций, возвращаемых значений функций и других структур кода. Это помогает выявлять ошибки на этапе компиляции и улучшает читаемость кода.

2. Дополнительные возможности: TypeScript предоставляет ряд дополнительных возможностей, таких как интерфейсы, перечисления, обобщенные типы (generics), декораторы и многое другое, которых нет в JavaScript.

3. Компиляция: TypeScript код компилируется в обычный JavaScript, поэтому его можно использовать везде, где поддерживается JavaScript. Это означает, что вы можете писать код на TypeScript и использовать его как в браузере, так и на сервере.

4. Обратная совместимость: TypeScript является надстройкой над JavaScript, поэтому весь допустимый JavaScript код также является допустимым кодом TypeScript. Это означает, что вы можете постепенно переносить существующий JavaScript проект на TypeScript, не делая сразу больших изменений.

### Как TypeScript обрабатывает наследование и полиморфизм?
TypeScript поддерживает наследование и полиморфизм, что позволяет создавать иерархии классов и использовать их в более гибком и удобном формате. Вот как TypeScript обрабатывает эти концепции:

1. **Наследование классов**: TypeScript позволяет создавать классы, которые могут наследовать свойства и методы от других классов с помощью ключевого слова `extends`. Наследующий класс называется подклассом, а класс, от которого он наследует, - суперклассом или базовым классом.

   ```typescript
   class Animal {
       name: string;

       constructor(name: string) {
           this.name = name;
       }

       move(distanceInMeters: number = 0) {
           console.log(`${this.name} moved ${distanceInMeters}m.`);
       }
   }

   class Dog extends Animal {
       bark() {
           console.log('Woof! Woof!');
       }
   }
   ```

2. **Полиморфизм**: TypeScript поддерживает полиморфизм, что означает, что объекты различных типов могут быть обращены к одному и тому же методу, и в зависимости от типа объекта будет вызван соответствующий метод. Это достигается путем переопределения методов в дочерних классах.

   ```typescript
   class Animal {
       name: string;

       constructor(name: string) {
           this.name = name;
       }

       move(distanceInMeters: number = 0) {
           console.log(`${this.name} moved ${distanceInMeters}m.`);
       }
   }

   class Dog extends Animal {
       bark() {
           console.log('Woof! Woof!');
       }

       move(distanceInMeters: number = 5) {
           console.log(`${this.name} is running.`);
           super.move(distanceInMeters);
       }
   }
   ```

   В этом примере метод `move` переопределен в классе `Dog`, который вызывает метод `move` суперкласса `Animal`, но сначала выводит сообщение о беге. Таким образом, при вызове `move` для объекта типа `Dog` будет вызван переопределенный метод.

### Что такое типизация по форме (structural typing) в TypeScript, и как она отличается от типизации по назначению (nominal typing)?
В TypeScript типизация по форме (structural typing) и типизация по назначению (nominal typing) представляют разные подходы к определению совместимости типов. Давайте рассмотрим различия между ними:

1. **Типизация по форме (structural typing)**:
    - В этом подходе совместимость типов основана на структуре объектов или интерфейсов, а не на их имени или метке.
    - Два типа считаются совместимыми, если они содержат одинаковые наборы свойств с совместимыми типами.
    - Это означает, что если объект или интерфейс имеет все свойства другого объекта или интерфейса и их типы совместимы, то они считаются совместимыми.
    - Пример:

      ```typescript
      interface Animal {
          name: string;
          age: number;
      }
 
      interface Dog {
          name: string;
          age: number;
          bark(): void;
      }
 
      let animal: Animal = { name: 'Rex', age: 5 };
      let dog: Dog = { name: 'Buddy', age: 3, bark: () => console.log('Woof!') };
 
      animal = dog; // Совместимо, так как структура совпадает
      ```

2. **Типизация по назначению (nominal typing)**:
    - В этом подходе совместимость типов определяется на основе их имени или метки, а не на основе структуры.
    - Два типа считаются совместимыми только если они имеют один и тот же явно указанный тип или метку.
    - Это означает, что, даже если два объекта имеют одинаковую структуру, они считаются несовместимыми, если они имеют разные имена типов или метки.
    - TypeScript не поддерживает полноценную типизацию по назначению, но вы можете использовать приведение типов или явные проверки типов для эмуляции этого поведения.

Типизация по форме обычно используется в TypeScript, и она обеспечивает более гибкую систему типов, которая упрощает многократное использование кода и повторное использование компонентов.

### Что такое декораторы в TypeScript?
Декораторы в TypeScript - это специальные функции, которые позволяют добавлять метаданные или изменять поведение классов, методов, свойств или параметров функций во время их объявления. Декораторы предоставляют удобный способ применять повторяющиеся шаблоны кода или функциональность к различным частям вашего приложения.

В TypeScript декораторы могут быть применены к классам, методам, свойствам и параметрам функций. Они используются как аннотации перед объявлением элемента, которому нужно применить декоратор.


### Какие типовые гварды доступны в TypeScript?
В TypeScript гварды (guards) - это специальные типы, которые используются для проверки типов данных во время выполнения программы. Они позволяют обеспечить безопасность типов и выполнить дополнительные проверки перед доступом к данным. Вот некоторые типовые гварды, доступные в TypeScript:

1. `typeof` гвард:
    - Проверяет тип значения по его типу JavaScript (например, `string`, `number`, `boolean`, `function`, `object`, `symbol`, `undefined`).
    - Пример:
      ```typescript
      function isNumber(value: any): value is number {
          return typeof value === 'number';
      }
      ```

2. `instanceof` гвард:
    - Проверяет, является ли значение экземпляром определенного класса.
    - Пример:
      ```typescript
      class MyClass {}
      function isInstanceOfMyClass(value: any): value is MyClass {
          return value instanceof MyClass;
      }
      ```

3. `in` гвард:
    - Проверяет наличие свойства в объекте.
    - Пример:
      ```typescript
      function hasProperty(obj: any, prop: string): prop is keyof typeof obj {
          return prop in obj;
      }
      ```

4. `Array.isArray()`:
    - Проверяет, является ли значение массивом.
    - Пример:
      ```typescript
      function isArray(value: any): value is any[] {
          return Array.isArray(value);
      }
      ```

Гварды в TypeScript позволяют писать безопасный код, который автоматически проводит проверки типов и уменьшает вероятность ошибок во время выполнения программы. Они широко используются для обеспечения безопасности типов данных в различных контекстах, таких как валидация входных данных, фильтрация массивов и объектов, проверка экземпляров классов и многое другое.

### Что такое условные типы в TypeScript?
Условные типы в TypeScript позволяют определять тип на основе условия. Они используются для создания более сложных типов, которые зависят от значений других типов или условий во время компиляции. Условные типы включают в себя оператор `extends`, который позволяет задавать условия для типов.

Синтаксис условных типов выглядит следующим образом:

```typescript
T extends U ? X : Y
```

Где:
- `T` - тип, который мы проверяем.
- `U` - тип, с которым мы сравниваем `T`.
- `X` - тип, который возвращается, если `T` расширяет `U`.
- `Y` - тип, который возвращается, если `T` не расширяет `U`.

Пример использования условного типа:

```typescript
type TypeName<T> =
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends undefined ? "undefined" :
  T extends Function ? "function" :
  "object";

type StrOrNum = TypeName<string | number>; // "string" | "number"
type BoolOrFunc = TypeName<boolean | (() => void)>; // "boolean" | "function"
type AllTypes = TypeName<string | number | boolean | undefined | (() => void)>; // "string" | "number" | "boolean" | "undefined" | "function"
```

В этом примере `TypeName` принимает обобщенный тип `T` и на основе его значений возвращает соответствующий тип. Если `T` является строкой, возвращается `"string"`, если число - `"number"`, и так далее. Условные типы могут быть очень полезными при работе с обобщенными типами и помогают писать более гибкий и универсальный код в TypeScript.

### Какие утилитарные типы доступны в TypeScript и для чего они используются?
В TypeScript существует несколько утилитарных типов, которые предоставляют мощные инструменты для работы с типами данных. Некоторые из наиболее распространенных утилитарных типов:

1. `Partial<T>`: Создает тип, который делает все свойства типа `T` необязательными.
2. `Required<T>`: Создает тип, который делает все свойства типа `T` обязательными.
3. `Readonly<T>`: Создает тип, который делает все свойства типа `T` только для чтения.
4. `Pick<T, K>`: Создает тип, выбирающий из типа `T` только указанные свойства `K`.
5. `Omit<T, K>`: Создает тип, исключающий из типа `T` указанные свойства `K`.
6. `Record<K, T>`: Создает тип, представляющий объект с ключами типа `K` и значениями типа `T`.
7. `Exclude<T, U>`: Создает тип, исключающий из типа `T` все типы, которые являются подтипами `U`.
8. `Extract<T, U>`: Создает тип, содержащий все типы из `T`, которые являются подтипами `U`.
9. `NonNullable<T>`: Создает тип, исключающий из типа `T` типы `null` и `undefined`.
10. `ReturnType<T>`: Получает тип возвращаемого значения функции типа `T`.
11. `Parameters<T>`: Получает тип параметров функции типа `T`.
12. `ConstructorParameters<T>`: Получает тип параметров конструктора функции типа `T`.
13. `InstanceType<T>`: Получает тип экземпляра объекта типа `T`.

Эти утилитарные типы облегчают работу с типами данных, уменьшают дублирование кода и повышают безопасность при написании TypeScript-кода. Они являются мощными инструментами для создания сложных типов и улучшения производительности разработки.

### Что такое дженерик типы и для чего они используются?
Дженерик типы в TypeScript представляют собой параметризованные типы данных, которые позволяют создавать компоненты (функции, классы, интерфейсы и т. д.), работающие с различными типами данных, сохраняя при этом типовую безопасность. Они позволяют создавать универсальные и гибкие компоненты, которые могут работать с различными типами данных без необходимости явного указания конкретного типа.

Дженерики используются для следующих целей:

1. **Повышение гибкости**: Дженерики позволяют создавать компоненты, которые могут работать с разными типами данных, а не ограничиваться только одним конкретным типом.

2. **Безопасность типов**: Дженерики обеспечивают безопасность типов данных во время компиляции, что позволяет выявлять ошибки в типах данных на этапе разработки.

3. **Повторное использование кода**: Дженерики позволяют создавать универсальные компоненты, которые можно повторно использовать в разных контекстах с разными типами данных.

4. **Поддержка различных типов данных**: Дженерики позволяют создавать абстрактные компоненты, которые могут работать с различными типами данных без потери безопасности типов.

Пример использования дженериков:

```typescript
function identity<T>(arg: T): T {
    return arg;
}

let output = identity<string>("hello");  // возвращает строку "hello"
let output2 = identity<number>(123);    // возвращает число 123
```

В этом примере `T` является дженерик типом, который принимает тип данных, переданный при вызове функции `identity`. Таким образом, функция `identity` может быть использована с разными типами данных, сохраняя при этом типовую безопасность.


### Что такое conditional types?
Условные типы (conditional types) в TypeScript представляют собой конструкцию, которая позволяет определять типы данных на основе условий. Это позволяет создавать типы, которые зависят от значений других типов.

Основная идея условных типов состоит в том, что тип зависит от результата проверки какого-либо условия. Такие типы используют ключевое слово `extends` для определения условий.

Пример использования условных типов:

```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<string>;  // A: true
type B = IsString<number>;  // B: false
```

В этом примере `IsString` - это условный тип, который проверяет, является ли тип `T` строковым. Если `T` является строкой (`T extends string`), то результатом будет тип `true`, иначе - тип `false`.

### Что такое интерфейсы и для чего они используются?
В TypeScript интерфейсы используются для определения структуры объекта или класса. Они позволяют описать форму объекта, указав набор свойств и их типы данных, а также опциональные свойства или методы. Интерфейсы могут также содержать описания методов, которые должны быть реализованы в классах.

Основные цели использования интерфейсов:

1. **Определение структуры данных**: Интерфейсы позволяют явно определить, какие свойства и методы должны быть доступны в объекте или классе.

2. **Облегчение работы с типами**: Интерфейсы позволяют создавать пользовательские типы данных, что делает код более понятным и уменьшает вероятность ошибок при работе с данными.

Пример использования интерфейса:

```typescript
interface Person {
    name: string;
    age: number;
    greet(): void;
}

class Student implements Person {
    constructor(public name: string, public age: number) {}
    greet() {
        console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
    }
}

const student = new Student("Alice", 20);
student.greet(); // Output: Hello, my name is Alice and I'm 20 years old.
```

В этом примере интерфейс `Person` определяет структуру объекта, который должен содержать свойства `name` (строка), `age` (число) и метод `greet`, возвращающий `void`. Класс `Student` реализует этот интерфейс, поэтому он должен содержать все свойства и методы, определенные в интерфейсе `Person`.

### Чем интерфейсы отличаются от типов?
В TypeScript интерфейсы (interfaces) и типы (types) похожи, но есть и различия:

1. **Назначение и назначение**:
    - **Интерфейсы**: Используются для определения формы (структуры) объекта или класса. Интерфейсы могут содержать только объявления членов, включая свойства и методы.
    - **Типы**: Могут представлять любой тип данных, включая примитивные типы, объекты, массивы, функции и так далее. Они могут быть более общими и могут содержать любую форму данных.

2. **Объединение и пересечение**:
    - **Интерфейсы**: Не могут объединяться или пересекаться. Это означает, что нельзя создать интерфейс, на основе нескольких других интерфейсов.
    - **Типы**: Могут быть объединены и пересечены с помощью операторов `|` (или) и `&` (и) соответственно. Это позволяет создавать более сложные типы данных.

3. **Расширение**:
    - **Интерфейсы**: Могут расширяться другими интерфейсами с помощью ключевого слова `extends`.
    - **Типы**: Не могут расширяться другими типами.

### Что такое приведение типов (type assertion) в TypeScript, и как его правильно использовать?
Приведение типов (type assertion) в TypeScript - это способ явно указать компилятору TypeScript на тип переменной, когда он не может определить его автоматически. Это используется в ситуациях, когда программист уверен, что тип переменной определен правильно, но компилятор TypeScript не может этого определить.

Существует два способа выполнить приведение типов в TypeScript:

1. **Синтаксис угловых скобок (`<тип>`)**:
   ```typescript
   let someValue: any = "this is a string";
   let strLength: number = (<string>someValue).length;
   ```
2. **Синтаксис ключевого слова `as`**:
   ```typescript
   let someValue: any = "this is a string";
   let strLength: number = (someValue as string).length;
   ```

Оба способа равнозначны и выполняют ту же функцию. Их выбор часто зависит от предпочтений стиля кодирования и согласованности с уже существующим кодом.

Важно помнить, что при использовании приведения типов вы должны быть уверены в правильности типа, которым вы приводите переменную. Если приведение типов несовместимо с фактическим типом переменной, это может привести к ошибкам времени выполнения.
