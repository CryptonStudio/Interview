# Вопросы для интервью по теме: Javascript

### Для чего используется оператор "&&" и оператор "||"?

это логические операторы `и` и `или`

### В чем разница между операторами "==" и "==="?

Строгое и не строгое сравнение

Пример:
```go
const a = 5 // число
const b = '5' // строка

a == b //truе, не сравнивает типы

a === b //false, т.к. разные типы
```

### Для чего используется оператор "!!"?

Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому (`boolean`) значению.

Пример:
```go
console.log(!!null) // false
console.log(!!undefined) // false
console.log(!!'') // false
console.log(!!0) // false
console.log(!!NaN) // false
console.log(!!' ') // true
console.log(!!{}) // true
console.log(!![]) // true
console.log(!!1) // true
console.log(!![].length) // false
```

### В чем разница между операторами "==" и "==="?

Строгое и не строгое сравнение

Пример:
```go
const a = 5 // число
const b = '5' // строка

a == b //truе, не сравнивает типы

a === b //false, т.к. разные типы
```

## Что такое неявное преобразование типов и в каких случаях оно встречается в Javascript?

Неявное преобразование типов происходит, когда операция или функция ожидает определённый тип данных, но получает значение другого типа. 

В этом случае JavaScript автоматически преобразует типы данных, чтобы выполнить операцию или функцию.

Неявное преобразование типов может привести к неожиданным результатам, поэтому важно понимать, когда и как оно происходит.


Пример:
```go

10 + "5"; // В результате будет "105", так как число 10 преобразуется в строку для конкатенации

10 == "10"; // В результате будет true, так как число 10 неявно преобразуется в строку для сравнения

if (1) { /* код */ } // Значение 1 неявно преобразуется в boolean для выполнения условия
```

### Какой тип имеют ключи у объекта в Javascript?

Ответ: Ключи в объекте имеют строковый тип, `string`.


### Что выведут логи?

```go
const a = {}
a[state] = 1
console.log(a.state)
a.state = 2
console.log(a.state)
```

Ответ: ничего, будет ошибка, т.к. переменная `state` не объявлена

что нужно сделать что бы код заработал?

(два варианта решения или объявить переменную  или передавать в скобки строку `'state'`)

```go
const a = {}
let state = 'key'
a[state] = 1
console.log(a.state)
a.state = 2
console.log(a.state)
```
если объявить переменную, то в этом случае первый лог выдаст `undefined`, а второй `2`

если передать строку `state`, то логи выведут `1` и `2`


### Что выведет консоль лог и почему?


```go
const a = {}
const b ={}
const c = {}
a[b] = 'b'
a[c] = 'c'
console.log(a)
```


Ответ: Лог выведет – `{ [object Object]: 'c' }`, т.к. произойдет неявное преобразование объекта к типу `string`, если у объекта явно вызвать `.toString()`, то получится ` [object Object]`.


### В чем разница записей?


```go
const msg = 'Hello'
console.log( { message: msg} )
```

```go
const msg = 'Hello'
console.log( { msg } )
```


Ответ: В первом случае выведет объект `{ message: 'Hello' }`, a во втором случае получится объект `{ msg: 'Hello' }`, т.к. в качестве ключа берется названия переменной

#### Как сделать так, чтобы вывелось `{ Hello: 'Hello' }`?

Ответ:  `{ [msg]: msg }`, квадратные скобки возьмут значение переменной, а не ее название.



## Что такое деструктуризация? приведите примеры

Ответ: это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

Пример:
```go
const person = { name: 'Alice', age: 30, city: 'New York' };

// Извлечение свойств объекта в отдельные переменные
const { name, age } = person;
console.log(name); // Вывод: 'Alice'
console.log(age); // Вывод: 30
```

### При деструктуризации идет копирование значения или ссылка на это значение?

Ответ: Приметивные типы, такие как, числа и строки копируют значение, а сложные типы, такие как, объекты и массивы идут по ссылке

Поэтому изменяя объект декструктурированный из другого объекта, этот объект поменяется и в исходном объекте это стоит учитывать при деструктуризации входных параметров в методы/функции

## Для чего используется спред оператор `...`? приведите пример

Ответ: Оператор расширения позволяет выражению расширяться в местах с множеством аргументов (для вызовов функций) или множестве элементов (для массивов).

Пример:
```go
const arr1 = [1, 2];
const arr2 = [3, 4];
const combinedArr = [...arr1, ...arr2];
console.log(combinedArr); // Вывод: [1, 2, 3, 4]
```


## Что такое ассинхронный код? 

Приведите примеры с `Promise` и `async await`


Ответ: Это код, который выполняется не последовательно от начала до конца, а в определенное время или в ответ на определенное событие.

Пример:
```go
// Пример асинхронной функции, возвращающей промис
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Данные были успешно загружены');
    }, 2000);
  });
}

fetchData()
  .then(data => {
    console.log(data); // Вывод: 'Данные были успешно загружены'
  })
  .catch(error => {
    console.error(error);
  });
  
  // Использование async/await для выполнения асинхронной операции
async function getData() {
  try {
    const data = await fetchData();
    console.log(data); // Вывод: 'Данные были успешно загружены'
  } catch (error) {
    console.error(error);
  }
}

getData();

```

### Что делает `Promise.all()`?

Приведите примеры.

Ответ: это метод в JavaScript, который принимает массив промисов и возвращает новый промис, который будет разрешен, когда все промисы в массиве будут разрешены, или будет отклонен с результатом первого отклоненного промиса.

Пример:
```go
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Промис 1 завершен');
  }, 2000);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Промис 2 завершен');
  }, 1500);
});

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Промис 3 завершен');
  }, 1000);
});

// Использование Promise.all() для ожидания завершения всех промисов
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results);
    // Вывод: ['Промис 1 завершен', 'Промис 2 завершен', 'Промис 3 завершен']
  })
  .catch((error) => {
    console.error(error);
  });
```

### Что делает `Promise.allSetled()`?

Приведите примеры.

Ответ: то метод в JavaScript, который принимает массив промисов и возвращает новый промис, который разрешается, когда все промисы в массиве завершатся, `независимо от того, были они разрешены или отклонены`. Результатом разрешенного промиса будет `массив объектов`, представляющих результаты каждого промиса.

Пример:
```go
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Промис 1 завершен');
  }, 2000);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('Ошибка: Промис 2 отклонен');
  }, 1500);
});

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Промис 3 завершен');
  }, 1000);
});

// Использование Promise.allSettled() для ожидания завершения всех промисов
Promise.allSettled([promise1, promise2, promise3])
  .then((results) => {
    console.log(results);
    /*
    Вывод:
    [
      { status: 'fulfilled', value: 'Промис 1 завершен' },
      { status: 'rejected', reason: 'Ошибка: Промис 2 отклонен' },
      { status: 'fulfilled', value: 'Промис 3 завершен' }
    ]
    */
  });
```
### Что такое Event loop?

Что такое `Microtask` и `Macrotask`?


Ответ: 

Event loop - это механизм в браузере или среде выполнения JavaScript, который обрабатывает выполнение асинхронного кода и событий. Event loop позволяет JavaScript быть однопоточным, но все еще обрабатывать асинхронные операции, такие как таймауты, обработка событий и выполнение промисов.

Microtask и Macrotask - это два типа задач, которые могут быть добавлены в очередь для выполнения в Event loop. Microtasks обычно имеют более высокий приоритет и выполняются после каждого выполненного скрипта или после выполнения Macrotask, в то время как Macrotasks выполняются в ответ на внешние события, такие как события таймаута, ввода-вывода и анимации.


### Что выведет консоль лог и почему?


```go
console.log('sync 1')

setTimeout(() => {
    console.log('setTimeout 2');
    setTimeout(() => {
        console.log('setTimeout inside setTimeout 3');
    }, 0)
    Promise.resolve().then(() => {
        console.log('Promise inside setTimeout 4');
        setTimeout(() => {
            console.log('setTimeout inside promise 5');
        }, 0)
    })
    console.log('setTimeout 6');
}, 0)

setTimeout(() => {
    console.log('setTimeout 7');
})

Promise.resolve().then(() => {
    console.log('promise 8');
})

Promise.resolve().then(() => {
    console.log('promise 9');
    Promise.resolve().then(() => {
        console.log('promise inside promise 10');
    })
})

console.log('sync 11')

```


Ответ: Лог выведет 


```go
sync 1
sync 11
promise 8
promise 9
promise inside promise 10
setTimeout 2
setTimeout 6
Promise inside setTimeout 4
setTimeout 7
setTimeout inside setTimeout 3
setTimeout inside promise 5
```

, т.к. Сначала выполнится синхронный код, поэтому `sync 1` и `sync 11` выводятся первыми.
Затем обработка Microtasks: выполняется первое Microtask `Promise.resolve().then(() => { console.log('promise 8'); })`, затем второе Microtask `Promise.resolve().then(() => { console.log('promise 9'); ... })` и вложенный Microtask `Promise.resolve().then(() => { console.log('promise inside promise 10'); })`.
Затем начинается выполнение Macrotasks: `setTimeout(() => { console.log('setTimeout 2'); ... })` добавляет Macrotask в очередь, затем `setTimeout(() => { console.log('setTimeout 7'); })`.
Внутри первого `setTimeout` происходит добавление новых Macrotasks и Microtasks, их выполнение происходит в порядке добавления в очередь.


Главное, что нужно понять во всем этом – это то что `сначала выполняется синхронный код`, потом `все микротаски`, когда они кончаются выполняется `одна макротаска`, затем если появились новые микротаски `выполняются все` они (макротаска может породить микротаску/ки), если микротасок не появилась выполнится `следующая (одна)` макротаска и опять будут выполнятся все микротаски если они есть, и так получается цикл событий `Event loop`.


