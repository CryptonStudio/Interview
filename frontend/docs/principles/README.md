# Вопросы для интервью по теме: Principles


### Какие основные принципы чистого кода вы знаете?
Основные принципы чистого кода включают в себя:

1. **Ясность и однозначность:** Код должен быть легко читаемым и понятным для других разработчиков, а также для вас самого через какое-то время.
    - *Хороший пример:* Использование понятных и осмысленных имен переменных, функций и классов.
    - *Плохой пример:* Использование сокращений и аббревиатур в именах без ясного объяснения их значения.

2. **Минимизация дублирования кода:** Избегайте повторения одного и того же кода в разных частях программы, следуйте принципу DRY (Don't Repeat Yourself).
    - *Хороший пример:* Вынос общей логики в отдельную функцию или метод, которую можно использовать повторно.
    - *Плохой пример:* Копирование и вставка одного и того же блока кода в разные места программы.

3. **Маленькие и простые функции:** Разбивайте код на маленькие функции с одной конкретной задачей для лучшей читаемости и управляемости.
    - *Хороший пример:* Функция, которая выполняет только одно действие, например, вычисление суммы элементов массива.
    - *Плохой пример:* Функция, которая выполняет множество различных действий в зависимости от условий.

4. **Комментирование:** Добавляйте комментарии к коду только там, где это действительно необходимо для объяснения сложной логики или особенностей реализации.
    - *Хороший пример:* Комментарий, объясняющий назначение или предполагаемое поведение функции.
    - *Плохой пример:* Избыточные или бессмысленные комментарии, которые не добавляют ничего полезного к пониманию кода.

5. **Тестирование:** Пишите автоматизированные тесты для вашего кода, чтобы убедиться в его корректности и предотвратить внесение ошибок при изменениях.
    - *Хороший пример:* Набор тестов, покрывающих различные аспекты функциональности вашего кода.
    - *Плохой пример:* Отсутствие тестов или неполные тесты, которые не проверяют все возможные случаи использования.


### Что такое SOLID и что значат его принципы?

1. **Принцип единственной ответственности (Single Responsibility Principle - SRP):**
    - **Хороший пример:** Класс, который отвечает только за одну конкретную функциональность, например, класс управления базой данных, который занимается только операциями с базой данных.
    - **Плохой пример:** Класс, который отвечает за несколько разноплановых задач, таких как обработка данных и взаимодействие с пользовательским интерфейсом.

2. **Принцип открытости/закрытости (Open/Closed Principle):**
    - **Хороший пример:** Использование интерфейсов и абстракций для создания расширяемой архитектуры, которая может быть изменена без изменения существующего кода.
    - **Плохой пример:** Прямая модификация существующего кода при добавлении новых функций, что приводит к рискам нарушения работоспособности других частей программы.

3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):**
    - **Хороший пример:** Все подклассы должны быть взаимозаменяемы с их базовым классом без изменения ожидаемого поведения программы.
    - **Плохой пример:** Изменение поведения подкласса так, что это приводит к нарушению ожидаемого поведения базового класса.

4. **Принцип разделения интерфейса (Interface Segregation Principle - ISP):**
    - **Хороший пример:** Использование маленьких и четко определенных интерфейсов, соответствующих конкретным потребностям клиентского кода.
    - **Плохой пример:** Создание общего интерфейса, который включает в себя слишком много методов, из которых некоторые не используются в конкретных реализациях.

5. **Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):**
    - **Хороший пример:** Использование внедрения зависимостей (dependency injection) для создания слабосвязанных компонентов, что обеспечивает гибкость и переиспользуемость кода.
    - **Плохой пример:** Прямая зависимость от конкретной реализации, что делает код менее гибким и трудным для тестирования.

![img_1.png](img_1.png)

### Что такое DRY принцип (Don't Repeat Yourself) и почему его важно соблюдать?
Принцип DRY (Don't Repeat Yourself) заключается в том, чтобы избегать дублирования кода в программе. Это означает, что каждый кусок информации должен иметь единственное, определенное место в коде. Повторное использование кода снижает его сложность, облегчает поддержку и обновление, а также уменьшает вероятность ошибок.

![img_2.png](img_2.png)

### Что такое KISS?
Принцип KISS, который означает « Будь простым, глупый », подчеркивает важность простоты в проектировании и разработке программного обеспечения. Цель состоит в том, чтобы отдать приоритет простым решениям над сложными. Сохраняя наш код простым, мы можем улучшить его понятность, удобство использования и поддержку. Принцип KISS применим не только к коду, но и к различным аспектам разработки программного обеспечения, включая архитектуру и дизайн пользовательского интерфейса.

Преимущества принципа KISS
Соблюдение принципа KISS дает ряд преимуществ в контексте разработки цифровых продуктов:


Улучшенный пользовательский опыт: пользователи предпочитают интуитивно понятные, простые в использовании интерфейсы и простые рабочие процессы. Придерживаясь простоты, мы можем обеспечить удобство работы и оправдать ожидания пользователей.
Эффективное тестирование. Более простые структуры программного обеспечения облегчают тестирование, включая автоматическое тестирование. Благодаря меньшей сложности тестирование становится проще и эффективнее, что приводит к повышению качества кода.
Более простое обслуживание: более простая база кода снижает сложность и делает обслуживание и привлечение новых членов команды более эффективными. Избегая ненужных функций и придерживаясь стандартов кодирования, мы можем упростить процесс разработки.
Реализация принципа KISS
Есть несколько способов реализовать принцип KISS в нашем коде. Один из подходов — использовать понятные и описательные имена переменных и методов. Это улучшает читаемость и понимание кода. Избегайте ненужной сложности, устраняя дублированный код, удаляя неиспользуемые функции и придерживаясь установленных стандартов кодирования. Кроме того, рассмотрите возможность разделения обязанностей внутри наших классов и уровней нашего проекта, чтобы получить более модульную и удобную в обслуживании кодовую базу.

![img_3.png](img_3.png)

### Что значит правильное именование переменных, функций, классов и других структур и почему важно выбирать осмысленные имена?
Правильное именование переменных, функций, классов и других структур означает использование осмысленных имен, которые четко передают их назначение и функциональность. Это важно по нескольким причинам:

1. **Понятность кода:** Осмысленные имена делают код более понятным и легким для понимания другими разработчиками. Это помогает быстрее ориентироваться в коде и сокращает время на его анализ.

2. **Уменьшение ошибок:** Понятные имена уменьшают вероятность ошибок при работе с кодом. Когда названия структур отражают их суть, разработчику легче представить, как они должны использоваться.

3. **Повышение поддерживаемости:** Правильное именование облегчает поддержку кода в долгосрочной перспективе. Если другой разработчик или вы сами в будущем вернетесь к коду, легче понять его, если имена переменных и функций хорошо подобраны.

4. **Снижение сложности:** Понятные имена позволяют сократить количество комментариев в коде, так как они сами по себе являются информативными.

Примеры:

Хороший пример:
```go
func calculateTotalPrice(items []Item) float64 {
    var totalPrice float64
    for _, item := range items {
        totalPrice += item.Price
    }
    return totalPrice
}
```

Плохой пример:
```go
func calc(items []Item) float64 {
    var sum float64
    for _, i := range items {
        sum += i.Pr
    }
    return sum
}
```

В хорошем примере функция имеет понятное название `calculateTotalPrice`, которое явно описывает ее цель. Переменная `totalPrice` также имеет осмысленное имя, отражающее ее предназначение. В плохом примере функция и переменная имеют короткие и неинформативные имена, которые затрудняют понимание их назначения.

### Какие антипаттерны и непродуктивные практики есть при организации кода?
Некоторые антипаттерны и непродуктивные практики при организации кода включают в себя:

1. **Монолитное приложение:** Это крупное приложение, в котором весь функционал сосредоточен в одном месте, что делает его сложным для понимания, изменения и тестирования.

    - **Хороший пример:** Разделение приложения на модули, службы или компоненты, каждый из которых отвечает за определенную функциональность.
    - **Плохой пример:** Весь код находится в одном файле или пакете без разделения на логические компоненты.

2. **Ненужные комментарии:** Излишние или неинформативные комментарии в коде могут быть мешающими и могут ухудшить читаемость кода.

    - **Хороший пример:** Комментарии, которые объясняют сложные алгоритмы или предоставляют контекст для понимания кода.
    - **Плохой пример:** Комментарии, которые просто повторяют то, что уже очевидно из самого кода.

3. **Магические числа:** Числовые значения, которые встречаются в коде без объяснения их смысла, могут затруднить понимание кода.

    - **Хороший пример:** Использование констант или перечислений для обозначения числовых значений.
    - **Плохой пример:** Использование числа 100 в коде без объяснения его смысла.

4. **Дублирование кода:** Повторение одного и того же участка кода в разных частях приложения, что усложняет его поддержку и ведет к ошибкам при изменениях.

    - **Хороший пример:** Вынос общей логики в отдельную функцию или класс.
    - **Плохой пример:** Копирование и вставка участка кода в несколько мест.

5. **Ненужная сложность:** Добавление избыточной сложности в код без необходимости, что затрудняет его понимание и поддержку.

    - **Хороший пример:** Простое решение задачи без излишних ухищрений.
    - **Плохой пример:** Использование сложных алгоритмов или шаблонов там, где это необязательно.
6. **Функций с большим количеством параметров:** Создание функций с большим количеством параметров  —  не самая лучшая практика. Она может приводить к путанице, особенно когда код читают другие люди. Так, будущие разработчики испытают немало трудностей при попытке понять, какие обязательные или необязательные параметры нужно заполнять, особенно при условии добавления дополнительных параметров. Лучшая практика заключается в установлении максимального количества параметров в каждой функции (по крайней мере, не более трех-четырех).

    - **Хороший пример:**
    ```typescript
      function registerUser(data) {
        const {
          fullName, email, phoneNumber,
          gender, address, hobbies
         } = data
        //Логика регистрации пользователя
       }
   ```
    - **Плохой пример:**
      ```typescript
      function registerUser(fullName, email, phoneNumber, gender, address, hobbies) {
      //Логика регистрации пользователя
      }
      ```
